# Masterai.py
import ollama
import json

def linux_step_planning(user_message: str, current_path: str, conversation_history: list = None):
    """
    Generates a textual plan using Ollama, considering conversation history and environment.
    """
    print(f"User Input for Planning: '{user_message}'")
    print(f"Current Path for Planning: '{current_path}'")

    history_str = ""
    if conversation_history and isinstance(conversation_history, list):
        history_entries = []
        # Take last N messages, e.g., 6 (3 user/assistant pairs)
        for msg in conversation_history[-6:]:
            if "role" in msg and "content" in msg:
                 history_entries.append(f"- {msg['role']}: {msg['content']}")
        if history_entries:
            history_str = "Previous interactions (for context):\n" + "\n".join(history_entries) + "\n\n"

    system_prompt = (
        f"You are an expert Linux action planner. You are planning steps for execution within a minimal Ubuntu Docker container (running as root). "
        f"Your current working directory is '{current_path}'.\n\n"
        f"{history_str}" # Insert formatted history here
        f"Your primary task is to break down the LATEST user's request: '{user_message}' into a sequence of actionable, descriptive steps. "
        f"These steps will later be converted into actual Linux commands by a separate AI model.\n\n"
        f"**Context & Memory (VERY IMPORTANT):**\n"
        f"- Pay EXTREMELY close attention to filenames, content, and paths mentioned in the LATEST user's request AND in the 'Previous interactions' history.\n"
        f"- For verification tasks (e.g., 'verify the file', 'check content'), your plan MUST refer to the *EXACT* files and *PRECISE* content that were previously created or specified by the user in the current session. Do NOT invent generic filenames like 'notes.txt' or generic content like 'hello world' unless the user explicitly asked for those specific things.\n"
        f"  For instance, if history shows 'user: Create test.txt with \\'My Data\\'' and then 'assistant: echo \\'My Data\\' > test.txt', a subsequent user request 'verify it' MUST lead to a plan checking 'test.txt' for 'My Data'.\n\n"
        f"**Available Tools (Ubuntu minimal image - running as root, so 'sudo' is NOT needed for apt):\n"
        f"- Shells & Execution: sh, bash\n"
        f"- Package Manager: apt, apt-get. (Plan steps like 'Update package lists and install <package_name> using apt'. This implies `apt update && apt install -y <package_name>` will be generated by the command AI. DO NOT include 'sudo' in this description.)\n"
        f"- Core Utilities: ls, cp, mv, rm, echo, cat, touch, mkdir, rmdir, pwd, grep, find, xargs, wc, head, tail, sort, uniq, diff, patch\n" # Added a few more common ones
        f"- System Info: hostname, uname, id, whoami, date, df, free\n"
        f"- Process Utilities: sleep, kill, ps\n"
        f"- Environment Variables: env, export, printenv\n"
        f"- Basic Text Editor: `vi` (Hard to automate. For creating files with simple content, prefer descriptive steps like 'Write text \"some content\" to file \"filename.txt\"', which can be implemented using `echo`.)\n\n"
        f"**Commonly Unavailable Tools (require installation via apt, remember NO SUDO in description):\n"
        f"- Networking Utilities: curl, wget, netstat, ip\n"
        f"- Advanced Text Editors: nano, vim\n"
        f"- Version Control: git\n"
        f"- Programming Languages/Runtimes: python, python3, nodejs, gcc, make\n"
        f"- Compression Utilities: zip, unzip, tar (tar is often available, but if specific zip/unzip is needed, plan for installation)\n"
        f"- Documentation: man\n"
        f"- Other useful tools: tree, jq, net-tools (for ifconfig etc.)\n\n"
        f"**Critical Rule for Missing Tools:**\n"
        f"If the user's request needs a tool from 'Unavailable Tools' (or any other not listed as 'Available'), your plan MUST include a step to install it using apt. Example: 'Update package lists and install wget using apt.'\n\n"
        f"**Output Format (STRICT):**\n"
        f"You MUST output your plan as a SINGLE JSON object. This object must contain ONE key: \"linuxcommand\". "
        f"The value for \"linuxcommand\" must be a LIST of strings. Each string is a concise, descriptive step for a Linux command.\n"
        f"Each step MUST be directly translatable into a Linux command. Do NOT include meta-instructions like 'ask the user for more details' or 'prompt for input'. If more info is needed, the user should provide it in a new turn.\n"
        f"Do NOT include any conversational text, explanations, or numbering outside the JSON object or within the step descriptions themselves.\n\n"
        f"**Path Guidance:**\n"
        f"Use paths relative to the current directory ('{current_path}') if appropriate, or absolute paths if the context demands it.\n\n"
        f"**Example 1 (Tool needed):**\n"
        f"LATEST User Request: Download the example.com homepage and save it as example.html\n"
        f"Current Path: /app\n"
        f"Expected JSON Output:\n"
        f"{{\n"
        f'  "linuxcommand": [\n'
        f'    "Update package lists and install wget using apt.",\n'
        f'    "Download content from \'http://example.com\' and save it as \'example.html\' in the \'/app\' directory using wget."\n'
        f'  ]\n'
        f"}}\n\n"
        f"**Example 2 (Verification with specific context from history):**\n"
        f"Current Path: /home/user\n"
        f"Previous interactions (excerpt):\n"
        f"  - user: Create a file named 'report.docx' and write 'Project Alpha report' into it.\n"
        f"  - assistant: (commands to create report.docx with 'Project Alpha report')\n"
        f"LATEST User Request: 'Verify the report file was created correctly.'\n"
        f"Expected JSON Output (because 'report.docx' and 'Project Alpha report' are in history):\n"
        f"{{\n"
        f'  "linuxcommand": [\n'
        f'    "Check if the file \'report.docx\' exists in \'/home/user\'.",\n'
        f'    "Display the contents of the file \'/home/user/report.docx\' to verify it contains \'Project Alpha report\'."\n'
        f'  ]\n'
        f"}}\n\n"
        f"Now, meticulously plan the steps for the LATEST user request ('{user_message}') based on all the above instructions and provided context."
    )

    # The user_message for the API call is the immediate request.
    # The system_prompt now contains the broader context including history.
    messages_api = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": f"Based on all provided context and my latest request, generate the plan: {user_message}"}
    ]

    try:
        response = ollama.chat(
            model='qwen2.5-coder:7b', # Or your preferred model for planning
            messages=messages_api,
            format="json",
            options={"temperature": 0.1} # Lower temperature for more deterministic planning
        )
        raw_content = response.get('message', {}).get('content')

        if not raw_content:
            print("Error: Ollama response (planning) did not contain message content.")
            return None

        parsed_response = json.loads(raw_content)

        if isinstance(parsed_response, dict) and \
           "linuxcommand" in parsed_response and \
           isinstance(parsed_response["linuxcommand"], list):
            if all(isinstance(item, str) for item in parsed_response["linuxcommand"]):
                # Filter out empty steps, if any
                parsed_response["linuxcommand"] = [step for step in parsed_response["linuxcommand"] if step.strip()]
                if not parsed_response["linuxcommand"]: # If all steps were empty or just whitespace
                     print("Warning (planning): 'linuxcommand' list is empty after stripping.")
                     return None
                return parsed_response
            else:
                print("Warning (planning): Items in the 'linuxcommand' list are not all strings.")
                print(f"Raw content (planning): {raw_content}")
                return None
        else:
            print("Warning (planning): Ollama response was not in the expected JSON format (missing 'linuxcommand' key or not a list of strings).")
            print(f"Raw content (planning): {raw_content}")
            return None

    except json.JSONDecodeError as e:
        print(f"Error decoding JSON from Ollama (planning): {e}")
        print(f"Raw response content (planning) was: {raw_content if 'raw_content' in locals() else 'not available'}")
        return None
    except ollama.ResponseError as e:
        print(f"Ollama API Error (planning): {e.status_code} - {e.error if hasattr(e, 'error') else str(e)}")
        return None
    except Exception as e:
        print(f"An unexpected error occurred during planning: {e}")
        return None